```c++
////////////////////////////////////////////////////////////////////////////////
//                          __    ___                                         //
//                         /\ \__/\_ \                                        //
//   _____   _____   __  __\ \ ,_\//\ \                                       //
//  /\ '__`\/\ '__`\/\ \/\ \\ \ \/ \ \ \                                      //
//  \ \ \_\ \ \ \_\ \ \ \_\ \\ \ \_ \_\ \_                                    //
//   \ \ ,__/\ \ ,__/\ \____/ \ \__\/\____\                                   //
//    \ \ \   \ \ \   \/___/   \/__/\/____/                                   //
//     \/_/    \/_/                                                           //
//                                                                            //
//  pputl Preprocessor Utilities                                              //
//  Copyright (C) 2020 - 2022 Justin Collier <m@jpcx.dev>                     //
//                                                                            //
//    This program is free software: you can redistribute it and/or modify    //
//    it under the terms of the GNU General Public License as published by    //
//    the Free Software Foundation, either version 3 of the License, or       //
//    (at your option) any later version.                                     //
//                                                                            //
//    This program is distributed in the hope that it will be useful,         //
//    but WITHOUT ANY WARRANTY; without even the implied warranty of          //
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           //
//    GNU General Public License for more details.                            //
//                                                                            //
//  You should have received a copy of the GNU General Public License        ///
//  along with this program.  If not, see <https://www.gnu.org/licenses/>.  ////
//                                                                         /////
////////////////////////////////////////////////////////////////////////////////
//                                                                        `/////
//  PREAMBLE                                                               `////
//  --------                                                                `///
//  Forewarning: macros should be used sparingly  or not at all if possible. `//
//  C++ has evolved to facilitate  countless metaprogramming techniques that  //
//  should be preferred in most cases,  as they are predictable,  type-safe,  //
//  and common knowledge.  pputl is primarily intended for research purposes  //
//  and for  various edge cases  that must be solved using code duplication,  //
//  such as  certain  compile-time optimizations  that reduce  the number of  //
//  template specializations.                                                 //
//                                                                            //
//  ABOUT                                                                     //
//  -----                                                                     //
//  pputl is a  powerful C++ preprocessor utilities library  that implements  //
//  many high-level programming constructs including unsigned arithmetic and  //
//  comparisons, logic, control flow, generation, transformation, reduction,  //
//  function binding, overloading, and range selection.  pputl is completely  //
//  generated by a custom framework that transforms shorthand signatures and  //
//  library invocations into macros, tests, and documentation.                //
//                                                                            //
//  pputl requires  `__VA_ARGS__` and  `__VA_OPT__`  support (C++20) but has  //
//  no other dependencies;  it is a single-header library  with no includes.  //
//  Any preprocessor that supports  `__VA_ARGS__` and `__VA_OPT__` should be  //
//  able to run pputl.                                                        //
//                                                                            //
//  GUARANTEES                                                                //
//  ----------                                                                //
//  All  non-nullary pputl API functions are variadic and parse their inputs  //
//  after at least one expansion. This means that function execution results  //
//  can be used as  function arguments,  provided that  the result expresses  //
//  immediately.                                                              //
//                                                                            //
//  All pputl functions that  transform or select argument ranges  guarantee  //
//  consistent expansions across their inputs. In other words, inputs expand  //
//  a  fixed number of times,  regardless of their  position in the argument  //
//  list or of the  total argument quantity.  All functions in this category  //
//  have  known and documented  expansion counts.  Consistent expansions are  //
//  essential for various techniques that  manipulate preprocessor syntax by  //
//  transforming deferred parentheses.  See PTL_RECUR and PTL_REDUCE for two  //
//  examples of this.                                                         //
//                                                                            //
//  LIMITATIONS                                                               //
//  -----------                                                               //
//  By default,  pputl uses  8-bit unsigned integers  for its arithmetic and  //
//  comparison operations,  and its uint max serves as an upper bound to the  //
//  number of arguments for most functions.  Integers underflow and overflow  //
//  according to standard unsigned rules (max + 1 == 0, 0 - 1 == max).        //
//                                                                            //
//  Regarding whitespace,  pputl prefers  ", " over  "," for readability and  //
//  compatibility with formatter rules.  In most cases,  a space is inserted  //
//  after each arg comma;  however,  spaces are not inserted in cases  where  //
//  doing so would require extra computation. If consistency is desired, use  //
//  PTL_NORM to reset spacing.                                                //
//                                                                            //
//  pputl is unable to prevent error conditions resulting from concatenating  //
//  tokens that are  incompatible with the ## operator  such as '"' and '-'.  //
//  Concatenation is a technique used extensively by the library,  and there  //
//  are  several functions  that must concatenate inputs  (such as detection  //
//  features including  PTL_IS_UINT and PTL_IS_BOOL).  Tuples are detectable  //
//  using PTL_IS_TUPLE and most features in this category perform this check  //
//  before concatenation (if they can do so efficiently; PTL_CAT does not).   //
//                                                                            //
//  USAGE                                                                     //
//  -----                                                                     //
//  Include pputl.h to your project. Modify the top of codegen/codegen.h and  //
//  `make` to set a custom unsigned max or naming preferences.                //
//                                                                            //
//  TESTING                                                                   //
//  -------                                                                   //
//  pputl is extensively tested by the build system using static assertions.  //
//  Tests have been validated using g++ 11.2.1 and clang++ 13.0.0. To verify  //
//  on your system, open test.cc in an LSP-enabled editor or `make test`.     //
```

# Synopsis

## Contents

- [Arithmetic](#arithmetic)
  - [`PTL_INC`](#inc): increments a uint8
  - [`PTL_DEC`](#dec): decrements a uint8
- Comparisons
- [Control Flow](#control_flow)
  - [`PTL_IF`](#if): makes a choice using a boolean
- [Generation](#generation)
  - [`PTL_IOTA`](#iota): generates an integer sequence
  - [`PTL_REPEAT`](#repeat): generates args using repetition
  - [`PTL_TRANSFORM`](#transform): generate args using transformation
  - [`PTL_GEN`](#gen): generates args using a generator
- Logic
- [Metaprogramming](#metaprogramming)
  - [`PTL_EAT`](#eat): discards args
  - [`PTL_X`](#x): performs a single expansion
  - [`PTL_X_N`](#x_n): performs n single expansions
  - [`PTL_XX`](#xx): performs a double expansion
  - [`PTL_XX_N`](#xx_n): performs n double expansions
  - [`PTL_CALL`](#call): indirect invocation
  - [`PTL_BIND`](#bind): binds arguments to a function
  - [`PTL_NOTHING`](#nothing): nothing
  - [`PTL_NORM`](#norm): normalizes spacing around arg commas
  - [`PTL_GET`](#get)
  - [`PTL_SET`](#set)
  - [`PTL_FIRST`](#first)
  - [`PTL_FIRST_N`](#first_n)
  - [`PTL_PASTE`](#paste)
  - [`PTL_PASTE_ITEMS`](#paste_items)
  - [`PTL_REST`](#rest)
  - [`PTL_REST_N`](#rest_n)
- [Traits](#traits)
  - [`PTL_IS_ANYTHING`](#is_anything)
  - [`PTL_IS_BOOL`](#is_bool)
  - [`PTL_IS_EMPTY`](#is_bool)
  - [`PTL_IS_FALSE`](#is_false)
  - [`PTL_IS_NOTHING`](#is_nothing)
  - [`PTL_IS_SIZEY`](#is_sizey)
  - [`PTL_IS_TRUE`](#is_true)
  - [`PTL_IS_TUPLE`](#is_tuple)
  - [`PTL_IS_UINT8`](#is_uint8)
  - [`PTL_NARGS`](#nargs)
- [Transformations](#transformations)
  - [`PTL_CAT`](#cat)
  - [`PTL_CAT_ALL`](#cat_all)
  - [`PTL_CAT_N`](#cat_n)
  - [`PTL_STR`](#str)
- [Tuples](#tuples)
  - [`PTL_GET_ITEM`](#get_item)
  - [`PTL_ITEMS`](#items)
  - [`PTL_PUSH_FRONT`](#push_front)
  - [`PTL_SET_ITEM`](#set)
  - [`PTL_SIZE`](#size)
  - [`PTL_SLICE_N`](#slice_n)

<a name="arithmetic">## Arithmetic</a>

<a name="inc">[**`PTL_INC(n)`**](include/pputl/inc.h)</a>

```c++
// increment a uint8.

PTL_INC(0)   // 1
PTL_INC(254) // 255
PTL_INC(255) // 0
```

<a name="dec">[**`PTL_DEC(n)`**](include/pputl/dec.h)</a>

```c++
// decrement a uint8.

PTL_DEC(0)   // 255
PTL_DEC(1)   // 0
PTL_DEC(255) // 254
```

[**`PTL_ADD(a, b)`**](include/pputl/add.h)

```c++
// add two uint8s.

// \param a - uint8 number
// \param b - uint8 number
// \returns uint8 sum

PTL_ADD(0, 0)    // 0
PTL_ADD(0, 1)    // 1
PTL_ADD(1, 0)    // 1
PTL_ADD(1, 1)    // 2
PTL_ADD(0, 255)  // 255
PTL_ADD(1, 255)  // 0
PTL_ADD(10, 255) // 9
#ifdef PTL_DEBUG
  PTL_ADD((), 1)     // ERROR("PTL_ADD: arg a must be a uint8", ())
  PTL_ADD(0, 256)    // ERROR("PTL_ADD: arg b must be a uint8", 256)
  PTL_ADD()          // ERROR("PTL_ADD: requires exactly two args; none provided")
  PTL_ADD((1), 2, 3) // ERROR("PTL_ADD: requires exactly two args", (1), 2, 3)
#endif
```

[**`PTL_SUM(...)`**](include/pputl/sum.h)

```c++
// sum [0, 256) uint8s.

// \param ... - uint8s to sum (fewer than 256)
// \returns uint8 sum

PTL_SUM()              // 0
PTL_SUM(1)             // 1
PTL_SUM(2, 3)          // 5
PTL_SUM(4, 5, 6)       // 15
PTL_SUM(255, 255, 255) // 253
#ifdef PTL_DEBUG
  PTL_SUM((), foo, 32)        // ERROR("PTL_SUM: args must be uint8s", (), foo, 32)
  PTL_SUM(PTL_REPEAT(255), a) // ERROR("PTL_SUM: requires fewer than 256 args", PTL_REPEAT(255), a)
#endif
```

## Comparisons

[**`PTL_LT(l, r)`**](include/pputl/lt.h)

```c++
// uint8 less-than comparison.

// \param l - lhs uint8
// \param r - rhs uint8
// \returns bool

PTL_LT(0, 0) // 0
PTL_LT(0, 1) // 1
PTL_LT(1, 0) // 0
PTL_LT(1, 1) // 0
#ifdef PTL_DEBUG
  PTL_LT(a, 1)      // ERROR("PTL_LT: arg l must be a uint8", a)
  PTL_LT(0, b)      // ERROR("PTL_LT: arg r must be a uint8", b)
  PTL_LT(c, ())     // ERROR("PTL_LT: args must be uint8s", c, ())
  PTL_LT()          // ERROR("PTL_LT: requres exactly two args; none provided")
  PTL_LT((1), 2, 3) // ERROR("PTL_LT: requres exactly two args", (1), 2, 3)
#endif
```

[**`PTL_GT(l, r)`**](include/pputl/gt.h)

```c++
// uint8 greater-than comparison.

// \param l - lhs uint8
// \param r - rhs uint8
// \returns bool

PTL_GT(0, 0) // 0
PTL_GT(0, 1) // 0
PTL_GT(1, 0) // 1
PTL_GT(1, 1) // 0
#ifdef PTL_DEBUG
  PTL_GT(a, 1)      // ERROR("PTL_GT: arg l must be a uint8", a)
  PTL_GT(0, b)      // ERROR("PTL_GT: arg r must be a uint8", b)
  PTL_GT(c, ())     // ERROR("PTL_GT: args must be uint8s", c, ())
  PTL_GT()          // ERROR("PTL_GT: requres exactly two args; none provided")
  PTL_GT((1), 2, 3) // ERROR("PTL_GT: requres exactly two args", (1), 2, 3)
#endif
```

[**`PTL_LE(l, r)`**](include/pputl/le.h)

```c++
// uint8 less-than-or-equal-to comparison.

// \param l - lhs uint8
// \param r - rhs uint8
// \returns bool

PTL_LE(0, 0) // 1
PTL_LE(0, 1) // 1
PTL_LE(1, 0) // 0
PTL_LE(1, 1) // 1
#ifdef PTL_DEBUG
  PTL_LE(a, 1)      // ERROR("PTL_LE: arg l must be a uint8", a)
  PTL_LE(0, b)      // ERROR("PTL_LE: arg r must be a uint8", b)
  PTL_LE(c, ())     // ERROR("PTL_LE: args must be uint8s", c, ())
  PTL_LE()          // ERROR("PTL_LE: requres exactly two args; none provided")
  PTL_LE((1), 2, 3) // ERROR("PTL_LE: requres exactly two args", (1), 2, 3)
#endif
```

[**`PTL_GE(l, r)`**](include/pputl/ge.h)

```c++
// uint8 greater-than-or-equal-to comparison.

// \param l - lhs uint8
// \param r - rhs uint8
// \returns bool

PTL_GE(0, 0) // 1
PTL_GE(0, 1) // 0
PTL_GE(1, 0) // 1
PTL_GE(1, 1) // 1
#ifdef PTL_DEBUG
  PTL_GE(a, 1)      // ERROR("PTL_GE: arg l must be a uint8", a)
  PTL_GE(0, b)      // ERROR("PTL_GE: arg r must be a uint8", b)
  PTL_GE(c, ())     // ERROR("PTL_GE: args must be uint8s", c, ())
  PTL_GE()          // ERROR("PTL_GE: requres exactly two args; none provided")
  PTL_GE((1), 2, 3) // ERROR("PTL_GE: requres exactly two args", (1), 2, 3)
#endif
```

[**`PTL_EQ(a, b)`**](include/pputl/eq.h)

```c++
// uint8 equal-to comparison.

// \param l - lhs uint8
// \param r - rhs uint8
// \returns bool

PTL_EQ(0, 0) // 1
PTL_EQ(0, 1) // 0
PTL_EQ(1, 0) // 0
PTL_EQ(1, 1) // 1
#ifdef PTL_DEBUG
  PTL_EQ(a, 1)      // ERROR("PTL_EQ: arg l must be a uint8", a)
  PTL_EQ(0, b)      // ERROR("PTL_EQ: arg r must be a uint8", b)
  PTL_EQ(c, ())     // ERROR("PTL_EQ: args must be uint8s", c, ())
  PTL_EQ()          // ERROR("PTL_EQ: requres exactly two args; none provided")
  PTL_EQ((1), 2, 3) // ERROR("PTL_EQ: requres exactly two args", (1), 2, 3)
#endif
```

[**`PTL_NE(a, b)`**](include/pputl/ne.h)

```c++
// uint8 not-equal-to comparison.

// \param l - lhs uint8
// \param r - rhs uint8
// \returns bool

PTL_NE(0, 0) // 0
PTL_NE(0, 1) // 1
PTL_NE(1, 0) // 1
PTL_NE(1, 1) // 0
#ifdef PTL_DEBUG
  PTL_NE(a, 1)      // ERROR("PTL_NE: arg l must be a uint8", a)
  PTL_NE(0, b)      // ERROR("PTL_NE: arg r must be a uint8", b)
  PTL_NE(c, ())     // ERROR("PTL_NE: args must be uint8s", c, ())
  PTL_NE()          // ERROR("PTL_NE: requres exactly two args; none provided")
  PTL_NE((1), 2, 3) // ERROR("PTL_NE: requres exactly two args", (1), 2, 3)
#endif
```

<a name="control_flow">## Control Flow</a>

<a name="if">[**`PTL_IF(cond, t, f...)`**](include/pputl/if.h)</a>

```c++
// chooses first or rest based on 1 or 0.

PTL_IF(0, t)          // <nothing>
PTL_IF(1, t)          // t
PTL_IF(0, t, f)       // f
PTL_IF(1, t, f)       // t
PTL_IF(0, t, f, g, h) // f, g, h
PTL_IF(1, t, f, g, h) // t
```

<a name="generation">## Generation</a>

<a name="gen">[**`PTL_GEN(n, gen)`**](include/pputl/gen.h)</a>

```c++
// generates n args (<=255) using an index-based generator.
// compatible with bound functions.

// function must not itself invoke PTL_GEN.
// instead, use any of PTL_GEN_L1 through PTL_GEN_L7.
// note: PTL_GEN is an alias of PTL_GEN_L0.

PTL_GEN(3, PTL_ID)               // 0, 1, 2
PTL_GEN(3, PTL_INC)              // 1, 2, 3
PTL_GEN(3, PTL_BIND(PTL_CAT, v)) // v0, v1, v2

#define F(i) PTL_GEN(PTL_INC(i), PTL_ID)
PTL_GEN(2, F)    // PTL_GEN(1, PTL_ID), PTL_GEN(2, PTL_ID) <-- expansion
                 //                                            terminated
PTL_GEN_L1(2, F) // 0, 0, 1, 0, 1, 2 <-- nesting achieved
```

<a name="iota">[**`PTL_IOTA(n)`**](include/pputl/iota.h)</a>

```c++
// generates an increasing integer sequence of size n (<=255).

PTL_IOTA(0)   // <nothing>
PTL_IOTA(1)   // 0
PTL_IOTA(2)   // 0, 1
PTL_IOTA(3)   // 0, 1, 2

// to specify an initial value:
PTL_X(PTL_TRANSFORM(PTL_BIND(PTL_ADD, 3), PTL_IOTA(3))) // 3, 4, 5
```

<a name="repeat">[**`PTL_REPEAT(n, ...)`**](include/pputl/repeat.h)</a>

```c++
// repeats args n (<=255) times.

PTL_REPEAT(0)          // <nothing>
PTL_REPEAT(1)          // <nothing>
PTL_REPEAT(1, a)       // a
PTL_STR(PTL_REPEAT(2)) // ","
PTL_STR(PTL_REPEAT(3)) // ", ,"
PTL_REPEAT(4, a)       // a, a, a, a
PTL_REPEAT(3, a, b)    // a, b, a, b, a, b
PTL_REPEAT(3, a,b)     // a,b, a,b, a,b
```

<a name="transform">[**`PTL_TRANSFORM(transformer, args...)`**](include/pputl/transform.h)</a>

```c++
// transforms up to 255 args using a unary transformer.
// compatible with bound functions.

// function must not itself invoke PTL_TRANSFORM.
// instead, use any of PTL_TRANSFORM_L1 through PTL_TRANSFORM_L7
// note: PTL_TRANSFORM is an alias of PTL_TRANSFORM_L0.

#define OP(x) PTL_CAT(1, x)
PTL_TRANSFORM(OP)                        // <nothing>
PTL_TRANSFORM(OP, 2)                     // 12
PTL_TRANSFORM(OP, 2, 3)                  // 12, 13
int x[]{PTL_TRANSFORM(OP, PTL_IOTA(4))}; // { 10, 11, 12, 13 }

// compatible with PTL_BIND:

#define SURROUND(l, r, m, i) (l, m, r)
// ({ .v =, 1, }), ({ .v =, 2, }), ({ .v =, 3, }), ({ .v =, 4, })
PTL_TRANSFORM(PTL_BIND(SURROUND, { .v =, }), 1, 2, 3, 4)
// { .v = 1 }, { .v = 2 }, { .v = 3 }, { .v = 4 }
PTL_TRANSFORM(PTL_PASTE_ITEMS, \
              PTL_TRANSFORM(PTL_BIND(SURROUND, { .v =, }), 1, 2, 3, 4))

// nesting demonstration:

#define OP0(tup) PTL_TRANSFORM_L0(OP,  PTL_ITEMS(tup))
#define OP1(tup) PTL_TRANSFORM_L1(OP0, PTL_ITEMS(tup))
#define OP2(tup) PTL_TRANSFORM_L2(OP1, PTL_ITEMS(tup))

PTL_TRANSFORM_L1(OP0, (0, 1))           // 10, 11
PTL_TRANSFORM_L2(OP1, ((0, 1), (2, 3))) // 10, 11, 12, 13
// 10, 11, 12, 13, 14, 15, 16, 17
PTL_TRANSFORM_L3(OP2, (((0, 1), (2, 3)), ((4, 5), (6, 7))))
```

[**`PTL_JOIN(joiner, ...)`**](include/pputl/join.h)  
joins [0, 256) args.

```c++
#define SPACE(a, b) a b
#define DOT(a, b)   a.b
PTL_JOIN(SPACE, foo, bar, baz) // foo bar baz
PTL_JOIN(DOT,   foo, bar, baz) // foo.bar.ba
```

[**`PTL_REDUCE(reducer, initial, ...)`**](include/pputl/reduce.h)  
reduces [0, 256) args to one.
warn: `PTL_REDUCE` cannot be nested due to recursion restrictions. see `tools/genReduceMacro` to generate additional reduce macros.

```c++
#define REDUCER(accum, val, idx) accum - val
#define SUBEXPR(...)            PTL_REDUCE(REDUCER, 0, __VA_ARGS__)
SUBEXPR()        // 0
SUBEXPR(0)       // 0 - 0
SUBEXPR(1)       // 0 - 1
SUBEXPR(1, 2, 3) // 0 - 1 - 2 - 3
```

## Logic

[**`PTL_NOT(v)`**](include/pputl/not.h)

```c++
// logical NOT.

// \param v - bool
// \returns bool

PTL_NOT(0) // 1
PTL_NOT(1) // 0
#ifdef PTL_DEBUG
  PTL_NOT(())     // ERROR("PTL_NOT: arg must be a bool", ())
  PTL_NOT()       // ERROR("PTL_NOT: requires exactly one arg; none provided")
  PTL_NOT((1), 2) // ERROR("PTL_NOT: requires exactly one arg", (1), 2)
#endif
```

[**`PTL_AND(a, b)`**](include/pputl/and.h)

```c++
// logical AND.

// \param a - first bool
// \param b - second bool
// \returns bool

PTL_AND(0, 0) // 0
PTL_AND(0, 1) // 0
PTL_AND(1, 0) // 0
PTL_AND(1, 1) // 1
#ifdef PTL_DEBUG
  PTL_AND(c, 1)      // ERROR("PTL_AND: arg a must be a bool", c)
  PTL_AND(0, d)      // ERROR("PTL_AND: arg b must be a bool", d)
  PTL_AND(e, ())     // ERROR("PTL_AND: args must be bools", e, ())
  PTL_AND()          // ERROR("PTL_AND: requires exactly two args; none provided")
  PTL_AND((foo))     // ERROR("PTL_AND: requires exactly two args", (foo))
  PTL_AND((1), 2, 3) // ERROR("PTL_AND: requires exactly two args", (1), 2, 3)
#endif
```

[**`PTL_OR(a, b)`**](include/pputl/or.h)

```c++
// logical OR.

// \param a - first bool
// \param b - second bool
// \returns bool

PTL_OR(0, 0) // 0
PTL_OR(0, 1) // 1
PTL_OR(1, 0) // 1
PTL_OR(1, 1) // 1
#ifdef PTL_DEBUG
  PTL_OR(c, 1)      // ERROR("PTL_OR: arg a must be a bool", c)
  PTL_OR(0, d)      // ERROR("PTL_OR: arg b must be a bool", d)
  PTL_OR(e, ())     // ERROR("PTL_OR: args must be bools", e, ())
  PTL_OR()          // ERROR("PTL_OR: requires exactly two args; none provided")
  PTL_OR((foo))     // ERROR("PTL_OR: requires exactly two args", (foo))
  PTL_OR((1), 2, 3) // ERROR("PTL_OR: requires exactly two args", (1), 2, 3)
#endif
```

[**`PTL_XOR(a, b)`**](include/pputl/xor.h)

```c++
// logical XOR.

// \param a - first bool
// \param b - second bool
// \returns bool

PTL_XOR(0, 0) // 0
PTL_XOR(0, 1) // 1
PTL_XOR(1, 0) // 1
PTL_XOR(1, 1) // 0
#ifdef PTL_DEBUG
  PTL_XOR(c, 1)      // ERROR("PTL_XOR: arg a must be a bool", c)
  PTL_XOR(0, d)      // ERROR("PTL_XOR: arg b must be a bool", d)
  PTL_XOR(e, ())     // ERROR("PTL_XOR: args must be bools", e, ())
  PTL_XOR()          // ERROR("PTL_XOR: requires exactly two args; none provided")
  PTL_XOR((foo))     // ERROR("PTL_XOR: requires exactly two args", (foo))
  PTL_XOR((1), 2, 3) // ERROR("PTL_XOR: requires exactly two args", (1), 2, 3)
#endif
```

<a name="metaprogramming">## Metaprogramming</a>

<a name="eat">[**`PTL_EAT(...)`**](include/pputl/eat.h)</a>
eats arguments; expands to nothing.

```c++
// eats arguments; expands to nothing.

PTL_IF(0, PTL_CAT, PTL_EAT)(1, 2) // 12
PTL_IF(1, PTL_CAT, PTL_EAT)(1, 2) // <nothing>
```

<a name="x">[**`PTL_X(...)`**](include/pputl/x.h)</a>

```c++
// performs a single expansion (identity function).

      PTL_CALL(PTL_CAT, foo, bar)  // PTL_CAT ( foo, bar )
PTL_X(PTL_CALL(PTL_CAT, foo, bar)) // foobar
```

<a name="xx">[**`PTL_XX(...)`**](include/pputl/xx.h)</a>

```c++
// performs a double expansion. useful for bound invocations.

 PTL_X(PTL_CALL(PTL_BIND(PTL_CAT, foo), bar)) // PTL_CAT ( foo, bar )
PTL_XX(PTL_CALL(PTL_BIND(PTL_CAT, foo), bar)) // foobar
```

<a name="x_n">[**`PTL_X_N(n) => (...)`**](include/pputl/x_n.h)</a>

```c++
// performs n (1 <= n <= 255) single expansions.

// note: n=0 also performs a single expansion to ease composition.

// warn: unlike other pputl features, PTL_X_N and PTL_XX_N are
//       factory functions. this is required for PTL_X_N single
//       expansions and is mirrored by PTL_XX_N for consistency.

// PTL_X_N(1)(...) ~ PTL_X(...)
// PTL_X_N(2)(...) ~ PTL_X(PTL_X(...))
// PTL_X_N(3)(...) ~ PTL_X(PTL_X(PTL_X(...)))

// note: better to use PTL_XX_N for mutual recursion
#define REV(...)      PTL_X_N(PTL_MUL(2, PTL_NARGS(__VA_ARGS__)))( \
                          REV_A(__VA_ARGS__))
#define REV_A(...)               PTL_CALL(REV_B, __VA_ARGS__)
#define REV_B(_, ...) __VA_OPT__(PTL_CALL(REV_A, __VA_ARGS__), ) _

// 4, 3, a, b, z, y, x, c, d, 2, 1
REV(1, 2, REV(a, b, REV(x, y, z), c, d), 3, 4)

           REV(1, 2, 3, 4)  // REV_B ( 1, 2, 3, 4 )
PTL_X_N(1)(REV(1, 2, 3, 4)) // REV_A ( 2, 3, 4 ), 1
PTL_X_N(2)(REV(1, 2, 3, 4)) // REV_B ( 2, 3, 4 ), 1
PTL_X_N(3)(REV(1, 2, 3, 4)) // REV_A ( 3, 4 ), 2, 1
PTL_X_N(4)(REV(1, 2, 3, 4)) // REV_B ( 3, 4 ), 2, 1
PTL_X_N(5)(REV(1, 2, 3, 4)) // REV_A ( 4 ), 3, 2, 1
PTL_X_N(6)(REV(1, 2, 3, 4)) // REV_B ( 4 ), 3, 2, 1
PTL_X_N(7)(REV(1, 2, 3, 4)) // 4, 3, 2, 1
```

<a name="xx_n">[**`PTL_XX_N(n) => (...)`**](include/pputl/xx_n.h)</a>

```c++
// performs n (<=255) double expansions.
// useful for mutual recursion, as n can be set to depth.

// note: n=0 performs a single expansion to ease composition.

// warn: unlike other pputl features, PTL_X_N and PTL_XX_N are
//       factory functions. this makes single expansions possible.

// PTL_XX_N(1)(...) ~ PTL_XX(...)
// PTL_XX_N(2)(...) ~ PTL_XX(PTL_XX(...))
// PTL_XX_N(3)(...) ~ PTL_XX(PTL_XX(PTL_XX(...)))

#define REV(...)      PTL_XX_N(PTL_NARGS(__VA_ARGS__))( \
                          REV_A(__VA_ARGS__))
#define REV_A(...)               PTL_CALL(REV_B, __VA_ARGS__)
#define REV_B(_, ...) __VA_OPT__(PTL_CALL(REV_A, __VA_ARGS__), ) _

// 4, 3, a, b, z, y, x, c, d, 2, 1
REV(1, 2, REV(a, b, REV(x, y, z), c, d), 3, 4)

            REV(1, 2, 3, 4)  // REV_B ( 1, 2, 3, 4 )
PTL_XX_N(1)(REV(1, 2, 3, 4)) // REV_B ( 2, 3, 4 ), 1
PTL_XX_N(2)(REV(1, 2, 3, 4)) // REV_B ( 3, 4 ), 2, 1
PTL_XX_N(3)(REV(1, 2, 3, 4)) // REV_B ( 4 ), 3, 2, 1
PTL_XX_N(4)(REV(1, 2, 3, 4)) // 4, 3, 2, 1
```

<a name="call">[**`PTL_CALL(fn, args...)`**](include/pputl/call.h)</a>

```c++
// calls a function or bound function expression with the provided arguments.

// function must not itself invoke PTL_CALL.
// instead, use any of PTL_CALL_L1 through PTL_CALL_L7.
// note: PTL_CALL is an alias of PTL_CALL_L0.

PTL_CALL(PTL_STR)                                     // ""
PTL_CALL(PTL_STR, foo)                                // "foo"
PTL_CALL(PTL_STR, foo, bar)                           // "foo, bar"
PTL_CALL(PTL_BIND(PTL_STR, bar), foo)                 // "foo, bar"
PTL_CALL(PTL_BIND(PTL_BIND(PTL_STR, baz!), bar), foo) // "foo, bar, baz!"

#define F(...) PTL_CALL(PTL_X, PTL_STR)(__VA_ARGS__)
PTL_CALL(F, a)    // PTL_CALL(PTL_X, PTL_STR)(a) <-- expansion terminated
PTL_CALL_L1(F, a) // "a" <-- nesting achieved
```

<a name="bind">[**`PTL_BIND(fn, ...)`**](include/pputl/bind.h)</a>

```c++
// groups a function with args for later invocation.
// use PTL_CALL to execute. can be nested to prepend additional args.

PTL_BIND(PTL_STR)                               // (PTL_STR, ())
PTL_BIND(PTL_STR, foo)                          // (PTL_STR, (foo))
PTL_BIND(PTL_STR, foo, bar)                     // (PTL_STR, (foo, bar))
PTL_BIND(PTL_BIND(PTL_STR, bar), foo)           // (PTL_STR, (foo, bar))
PTL_CALL(PTL_BIND(PTL_BIND(PTL_STR, bar), foo)) // "foo, bar"
```

<a name="nothing">[**`PTL_NOTHING`**](include/pputl/nothing.h)</a>

```c++
// nothing.

PTL_IF(1, foo, PTL_NOTHING) // foo
PTL_IF(0, foo, PTL_NOTHING) // <nothing>
```

<a name="norm">[**`PTL_NORM(...)`**](include/pputl/norm.h)</a>

```c++
// normalizes the spacing of up to 255 args.

PTL_NORM()              // <nothing>
PTL_NORM(a)             // a
PTL_NORM(a,b)           // a, b
PTL_NORM(a, b ,c)       // a, b, c
PTL_NORM(a , ba bb , c) // a, ba bb, c
```

<a name="get">[**`PTL_GET(n, ...)`**](include/pputl/get.h)</a>

```c++
// gets the nth arg (<255).

PTL_GET(0, a, b) // a
PTL_GET(1, a, b) // b
```

<a name="set">[**`PTL_SET(idx, val, ...)`**](include/pputl/set.h)</a>

```c++
// sets the arg at idx (<=255) to val.
// requires at least idx+1 of args as input.

PTL_SET(0, c, a, b)        // c, b
PTL_SET(1, d, a, b)        // a, d
PTL_SET(2, e, a,b,c,d,e,f) // a, b, e, d,e,f
```

<a name="first">[**`PTL_FIRST(...)`**](include/pputl/first.h)</a>

```c++
// picks the first arg.

PTL_FIRST();     // <nothing>
PTL_FIRST(a);    // a
PTL_FIRST(a, b); // a
```

<a name="first_n">[**`PTL_FIRST_N(n, ...)`**](include/pputl/first_n.h)</a>

```c++
// picks the first n args (<=255).

PTL_FIRST_N(0);       // <nothing>
PTL_FIRST_N(1);       // <nothing>
PTL_FIRST_N(0, a);    // <nothing>
PTL_FIRST_N(1, a);    // a
PTL_FIRST_N(0, a, b); // <nothing>
PTL_FIRST_N(1, a, b); // a
PTL_FIRST_N(2, a, b); // a, b
```

<a name="paste">[**`PTL_PASTE(args...)`**](include/pputl/paste.h)</a>

```c++
// removes commas between arguments.

PTL_PASTE()        // <nothing>
PTL_PASTE(a)       // a
PTL_PASTE(a, b)    // a b
PTL_PASTE(a, b, c) // a b c
```

<a name="paste_items">[**`PTL_PASTE_ITEMS(tup)`**](include/pputl/paste_items.h)</a>

```c++
// extracts items from a tuple and removes the commas between them.

PTL_PASTE_ITEMS(())        // <nothing>
PTL_PASTE_ITEMS((a))       // a
PTL_PASTE_ITEMS((a, b))    // a b
PTL_PASTE_ITEMS((a, b, c)) // a b c
```

<a name="rest">[**`PTL_REST(...)`**](include/pputl/rest.h)</a>

```c++
// picks all args except the first.

PTL_REST();        // <nothing>
PTL_REST(a);       // <nothing>
PTL_REST(a, b);    // b
PTL_REST(a, b, c); // b, c
PTL_REST(a,b,c,d); // b,c,d
```

<a name="rest_n">[**`PTL_REST_N(n, ...)`**](include/pputl/rest_n.h)</a>

```c++
// picks the args **after** the first n (<=255).

PTL_REST_N(0);       // <nothing>
PTL_REST_N(1);       // <nothing>
PTL_REST_N(0, a);    // a
PTL_REST_N(1, a);    // <nothing>
PTL_REST_N(0, a, b); // a, b
PTL_REST_N(1, a, b); // b
PTL_REST_N(2, a, b); // <nothing>
```

<a name="traits">## Traits</a>

<a name="is_anything">[**`PTL_IS_ANYTHING(...)`**](include/pputl/is_anything.h)</a>

```c++
// detects if args is anything.

PTL_IS_ANYTHING()           // 0
PTL_IS_ANYTHING(foo)        // 1
PTL_IS_ANYTHING(foo, bar)   // 1
PTL_IS_ANYTHING(PTL_CAT(,)) // 0
```

<a name="is_bool">[**`PTL_IS_BOOL(...)`**](include/pputl/is_bool.h)</a>

```c++
// detects if args is a bool.

PTL_IS_BOOL()     // 0
PTL_IS_BOOL(())   // 0
PTL_IS_BOOL(0)    // 1
PTL_IS_BOOL(1)    // 1
PTL_IS_BOOL(2)    // 0
PTL_IS_BOOL(foo)  // 0
PTL_IS_BOOL(1, 0) // 0
```

<a name="is_empty">[**`PTL_IS_EMPTY(...)`**](include/pputl/is_empty.h)</a>

```c++
// detects if args is an empty tuple.

PTL_IS_EMPTY()           // 0
PTL_IS_EMPTY(())         // 1
PTL_IS_EMPTY((), ())     // 0
PTL_IS_EMPTY(foo)        // 0
PTL_IS_EMPTY(foo, bar)   // 0
PTL_IS_EMPTY((foo, bar)) // 0
```

<a name="is_false">[**`PTL_IS_FALSE(...)`**](include/pputl/is_false.h)</a>

```c++
// detects if args is false (boolean 0).

PTL_IS_FALSE()     // 0
PTL_IS_FALSE(())   // 0
PTL_IS_FALSE(0)    // 1
PTL_IS_FALSE(1)    // 0
PTL_IS_FALSE(2)    // 0
PTL_IS_FALSE(foo)  // 0
PTL_IS_FALSE(1, 0) // 0
```

<a name="is_nothing">[**`PTL_IS_NOTHING(...)`**](include/pputl/is_nothing.h)</a>

```c++
// detects if args is nothing.

PTL_IS_NOTHING()         // 1
PTL_IS_NOTHING(foo)      // 0
PTL_IS_NOTHING(foo, bar) // 0
```

<a name="is_sizey">[**`PTL_IS_SIZEY(...)`**](include/pputl/is_sizey.h)</a>

```c++
// detects if args is a sizey tuple.

PTL_IS_SIZEY()           // 0
PTL_IS_SIZEY(())         // 0
PTL_IS_SIZEY((), ())     // 0
PTL_IS_SIZEY(foo)        // 0
PTL_IS_SIZEY((foo))      // 1
PTL_IS_SIZEY(foo, bar)   // 0
PTL_IS_SIZEY((foo, bar)) // 1
```

<a name="is_true">[**`PTL_IS_TRUE(...)`**](include/pputl/is_true.h)</a>

```c++
// detects if args is true (boolean 1).

PTL_IS_TRUE()     // 0
PTL_IS_TRUE(())   // 0
PTL_IS_TRUE(0)    // 0
PTL_IS_TRUE(1)    // 1
PTL_IS_TRUE(2)    // 0
PTL_IS_TRUE(foo)  // 0
PTL_IS_TRUE(1, 0) // 0
```

<a name="is_tuple">[**`PTL_IS_TUPLE(...)`**](include/pputl/is_tuple.h)</a>

```c++
// detects if args is a tuple.

#define TUP (1, 2, 3)
PTL_IS_TUPLE()               // 0
PTL_IS_TUPLE(())             // 1
PTL_IS_TUPLE(TUP)            // 1
PTL_IS_TUPLE(PTL_ITEMS(TUP)) // 0
```

<a name="is_uint8">[**`PTL_IS_UINT8(...)`**](include/pputl/is_uint8.h)</a>

```c++
// detects if args is a uint8.

PTL_IS_UINT8()     // 0
PTL_IS_UINT8(())   // 0
PTL_IS_UINT8(0)    // 1
PTL_IS_UINT8(1)    // 1
PTL_IS_UINT8(255)  // 1
PTL_IS_UINT8(256)  // 0
PTL_IS_UINT8(foo)  // 0
PTL_IS_UINT8(1, 0) // 0
```

<a name="nargs">[**`PTL_NARGS(...)`**](include/pputl/nargs.h)</a>

```c++
// detects uint8 number of args.

// warning: if more than 255 args, expands to 256th arg.

PTL_NARGS()                // 0
PTL_NARGS(,)               // 2
PTL_NARGS(foo, bar, baz)   // 3
PTL_NARGS(PTL_REPEAT(255)) // 255
```

<a name="manipulators">## Manipulators</a>

<a name="cat">[**`PTL_CAT(l, r)`**](include/pputl/cat.h)</a>

```c++
// concatenates two args.

#define UNEXP(...) c, d
PTL_CAT(a, b)            // ab
PTL_CAT(PTL_CALL(UNEXP)) // cd
```

<a name="cat_all">[**`PTL_CAT_ALL(...)`**](include/pputl/cat_all.h)</a>

```c++
// concatenates <=255 args.

PTL_CAT_ALL()        // <nothing>
PTL_CAT_ALL(,,)      // <nothing>
PTL_CAT_ALL(1, 2, 3) // 123
```

<a name="cat_n">[**`PTL_CAT_N(n, ...)`**](include/pputl/cat_n.h)</a>

```c++
// concatenates n (<=255) args.

PTL_CAT_N(0)          // <nothing>
PTL_CAT_N(0, a)       // a
PTL_CAT_N(1, a)       // a
PTL_CAT_N(0, a, b)    // a, b
PTL_CAT_N(1, a, b)    // a, b
PTL_CAT_N(2, a, b)    // ab
PTL_CAT_N(0, a, b, c) // a, b, c
PTL_CAT_N(1, a, b, c) // a, b, c
PTL_CAT_N(2, a, b, c) // ab, c
PTL_CAT_N(3, a, b, c) // abc
```

<a name="str">[**`PTL_STR(...)`**](include/pputl/str.h)</a>

```c++
// stringizes args after an expansion.
PTL_STR()                           // ""
PTL_STR(foo, bar)                   // "foo, bar"
PTL_STR(qux,quz)                    // "qux,quz"
PTL_STR(PTL_CAT(foo, bar))          // "foobar"
PTL_STR(PTL_CAT PTL_LP a, b PTL_RP) // "PTL_CAT ( a, b )"
```

<a name="tuples">## Tuples</a>

<a name="get_item">[**`PTL_GET_ITEM(idx, tup)`**](include/pputl/get_item.h)</a>

```c++
// gets a tuple element using an index (<255).

PTL_GET_ITEM(0, (a, b)) // a
PTL_GET_ITEM(1, (a, b)) // b
```

<a name="items">[**`PTL_ITEMS(tup)`**](include/pputl/items.h)</a>

```c++
// extracts tuple items.

PTL_ITEMS(())               // <nothing>
PTL_ITEMS((1, 2, 3))        // 1, 2, 3
PTL_ITEMS(((a, b), (c, d))) // (a, b), (c, d)
```

<a name="push_front">[**`PTL_PUSH_FRONT(tup, front...)`**](include/pputl/push_front.h)</a>

```c++
// pushes args to the front of a tuple.

PTL_PUSH_FRONT(())        // ()
PTL_PUSH_FRONT((), a)     // (a)
PTL_PUSH_FRONT((c), a, b) // (a, b, c)
```

<a name="set_item">[**`PTL_SET_ITEM(idx, val, tup)`**](include/pputl/set_item.h)</a>

```c++
// sets the tuple element at idx to val (<=255).
// tuple must have at least idx+1 elements.

PTL_SET_ITEM(0, c, (a, b))        // (c, b)
PTL_SET_ITEM(1, d, (a, b))        // (a, d)
PTL_SET_ITEM(2, e, (a,b,c,d,e,f)) // (a, b, e, d,e,f)
```

<a name="size">[**`PTL_SIZE(tup)`**](include/pputl/size.h)</a>

```c++
// detects uint8 size of a tuple.

PTL_SIZE(())                // 0
PTL_SIZE((,))               // 2
PTL_SIZE((foo, bar, baz))   // 3
PTL_SIZE((PTL_REPEAT(255))) // 255
```

<a name="slice_n">[**`PTL_SLICE_N(begin, n, tup)`**](include/pputl/slice_n.h)</a>

```c++
// slices out a portion of a tuple given an index (<255) and n items (<=255).

PTL_SLICE_N(0, 0, (a, b, c, d)) // ()
PTL_SLICE_N(0, 1, (a, b, c, d)) // (a)
PTL_SLICE_N(0, 2, (a, b, c, d)) // (a, b)
PTL_SLICE_N(0, 3, (a, b, c, d)) // (a, b, c)
PTL_SLICE_N(0, 4, (a, b, c, d)) // (a, b, c, d)
PTL_SLICE_N(1, 0, (a, b, c, d)) // ()
PTL_SLICE_N(1, 1, (a, b, c, d)) // (b)
PTL_SLICE_N(1, 2, (a, b, c, d)) // (b, c)
PTL_SLICE_N(1, 3, (a, b, c, d)) // (b, c, d)
PTL_SLICE_N(2, 0, (a, b, c, d)) // ()
PTL_SLICE_N(2, 1, (a, b, c, d)) // (c)
PTL_SLICE_N(2, 2, (a, b, c, d)) // (c, d)
PTL_SLICE_N(3, 0, (a, b, c, d)) // ()
PTL_SLICE_N(3, 1, (a, b, c, d)) // (d)
```
